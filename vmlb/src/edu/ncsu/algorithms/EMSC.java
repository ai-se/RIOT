package edu.ncsu.algorithms;

import java.util.Comparator;
import java.util.HashMap;
import java.util.Random;

import jmetal.core.Algorithm;
import jmetal.core.Solution;
import jmetal.core.SolutionSet;
import jmetal.operators.crossover.Crossover;
import jmetal.operators.mutation.Mutation;
import jmetal.operators.selection.Selection;
import jmetal.operators.selection.SelectionFactory;
import jmetal.util.JMException;
import jmetal.util.PseudoRandom;

/**
 * This file implements the following paper Zhu et al. Evolutionary
 * multi-objective workflow scheduling in cloud (IEEE Tran on Parallel and
 * Distributed Systems 2016)
 * 
 * @author jianfeng
 *
 */

public class EMSC {

	public SolutionSet execute(HashMap<String, Object> para) throws ClassNotFoundException, JMException {
		SolutionSet res = null;
		switch ((String) para.get("algorithm")) {
		case "NSGAII":
			res = execNSGAII((String) para.get("dataset"), //
					(int) para.get("popSize"), //
					(int) para.get("maxEval"), //
					(double) para.get("cxProb"), //
					(double) para.get("cxRandChangeProb"), //
					(double) para.get("mutProb"), //
					(double) para.get("bitMutProb"), //
					(long) para.get("seed"));
			break;
		case "SPEA2":
			res = execSPEA2((String) para.get("dataset"), //
					(int) para.get("popSize"), //
					(int) para.get("maxEval"), //
					(int) para.get("arxvSize"), //
					(double) para.get("cxProb"), //
					(double) para.get("cxRandChangeProb"), //
					(double) para.get("mutProb"), //
					(double) para.get("bitMutProb"), //
					(long) para.get("seed"));
			break;
		case "MOEAD":
			res = execMOEAD((String) para.get("dataset"), //
					(int) para.get("popSize"), //
					(int) para.get("maxEval"), //
					(double) para.get("cxProb"), //
					(double) para.get("cxRandChangeProb"), //
					(double) para.get("mutProb"), //
					(double) para.get("bitMutProb"), //
					(long) para.get("seed"));
			break;
		default:
			System.err.println("algorithm must be correct!");
			System.exit(-1);
		}

		// sorting SolutionSet
		res.sort(new Comparator<Solution>() {
			public int compare(Solution o1, Solution o2) {
				return (int) (o1.getObjective(0) - o2.getObjective(0));
			}
		});

		for (int v = 0; v < res.size(); v++) {
			System.out.println(res.get(v));
		}

		return res;
	}

	private SolutionSet execNSGAII(String dataset, int popSize, int maxEval, double cxProb, double cxRandChangeProb,
			double mutProb, double bitMutProb, long seed) throws JMException, ClassNotFoundException {
		VmsProblem problem_ = new VmsProblem(dataset, new Random(seed));
		PseudoRandom.setRandomGenerator(new MyRandomGenerator(seed));
		Algorithm alg = new NSGAII(problem_);
		HashMap<String, Object> parameters = new HashMap<String, Object>();

		/** for all MOEA */
		alg.setInputParameter("populationSize", popSize); // WARNING MUST BE
															// EVEN
		alg.setInputParameter("maxEvaluations", maxEval);

		// add init seeds -- cheapeast and fastest schedule generated by HEFT
		// algorithm
		parameters.clear();
		parameters.put("dataset", dataset);
		parameters.put("seed", seed);
		parameters.put("maxSimultaneousIns", 10); // from moheft paper
		MOHEFT heft = new MOHEFT();
		alg.setInputParameter("seedInitPopulation", heft.execHEFTMinExtremes(parameters));

		parameters.clear();
		parameters.put("probability", cxProb);
		parameters.put("randomChangeProbability", cxRandChangeProb);
		parameters.put("problem", problem_);
		Crossover crossover = new ZhuCrossover(parameters);

		parameters.clear();
		parameters.put("probability", mutProb == -1.0 ? 1.0 / problem_.tasksNum : mutProb);
		parameters.put("bitMutationProbability", bitMutProb);
		parameters.put("problem", problem_);
		Mutation mutation = new ZhuMutation(parameters);

		parameters.clear();
		Selection selection = SelectionFactory.getSelectionOperator("BinaryTournament2", parameters);

		alg.addOperator("crossover", crossover);
		alg.addOperator("mutation", mutation);
		alg.addOperator("selection", selection);

		SolutionSet p = alg.execute();

		return p;
	}

	private SolutionSet execSPEA2(String dataset, int popSize, int maxEval, int arxvSzie, double cxProb,
			double cxRandChangeProb, double mutProb, double bitMutProb, long seed)
			throws JMException, ClassNotFoundException {
		VmsProblem problem_ = new VmsProblem(dataset, new Random(seed));
		PseudoRandom.setRandomGenerator(new MyRandomGenerator(seed));
		Algorithm alg = new SPEA2(problem_);
		HashMap<String, Object> parameters = new HashMap<String, Object>();

		/** for all MOEA */
		alg.setInputParameter("populationSize", popSize); // WARNING MUST BE
															// EVEN
		alg.setInputParameter("maxEvaluations", maxEval);
		/** for spea2 only */
		alg.setInputParameter("archiveSize", arxvSzie); // for spea2

		// add init seeds -- cheapeast and fastest schedule generated by HEFT
		// algorithm
		parameters.clear();
		parameters.put("dataset", dataset);
		parameters.put("seed", seed);
		parameters.put("maxSimultaneousIns", 10); // from moheft paper
		MOHEFT heft = new MOHEFT();
		alg.setInputParameter("seedInitPopulation", heft.execHEFTMinExtremes(parameters));

		parameters.clear();
		parameters.put("probability", cxProb);
		parameters.put("randomChangeProbability", cxRandChangeProb);
		parameters.put("problem", problem_);
		Crossover crossover = new ZhuCrossover(parameters);

		parameters.clear();
		parameters.put("probability", mutProb == -1.0 ? 1.0 / problem_.tasksNum : mutProb);
		parameters.put("bitMutationProbability", bitMutProb);
		parameters.put("problem", problem_);
		Mutation mutation = new ZhuMutation(parameters);

		parameters.clear();
		Selection selection = SelectionFactory.getSelectionOperator("BinaryTournament2", parameters);

		alg.addOperator("crossover", crossover);
		alg.addOperator("mutation", mutation);
		alg.addOperator("selection", selection);

		SolutionSet p = alg.execute();

		return p;
	}

	private SolutionSet execMOEAD(String dataset, int popSize, int maxEval, double cxProb, double cxRandChangeProb,
			double mutProb, double bitMutProb, long seed) throws JMException, ClassNotFoundException {
		VmsProblem problem_ = new VmsProblem(dataset, new Random(seed));
		PseudoRandom.setRandomGenerator(new MyRandomGenerator(seed));
		Algorithm alg = new MOEAD(problem_);
		HashMap<String, Object> parameters = new HashMap<String, Object>();

		/** for all MOEA */
		alg.setInputParameter("populationSize", popSize); // WARNING MUST BE
															// EVEN
		alg.setInputParameter("maxEvaluations", maxEval);

		// add init seeds -- cheapeast and fastest schedule generated by HEFT
		// algorithm
		parameters.clear();
		parameters.put("dataset", dataset);
		parameters.put("seed", seed);
		parameters.put("maxSimultaneousIns", 10); // from moheft paper
		MOHEFT heft = new MOHEFT();
		alg.setInputParameter("seedInitPopulation", heft.execHEFTMinExtremes(parameters));

		parameters.clear();
		parameters.put("probability", cxProb);
		parameters.put("randomChangeProbability", cxRandChangeProb);
		parameters.put("problem", problem_);
		Crossover crossover = new ZhuCrossover(parameters);

		parameters.clear();
		parameters.put("probability", mutProb == -1.0 ? 1.0 / problem_.tasksNum : mutProb);
		parameters.put("bitMutationProbability", bitMutProb);
		parameters.put("problem", problem_);
		Mutation mutation = new ZhuMutation(parameters);

		alg.addOperator("crossover", crossover);
		alg.addOperator("mutation", mutation);

		SolutionSet p = alg.execute();

		return p;
	}

	/**
	 * This is a DEMOSTRATION of EMSC algorithm. To do experiments, go to
	 * edu.ncsu.experiments
	 */
	public static void main(String[] args) throws JMException, ClassNotFoundException {
		// for (String model : Infrastructure.models) {
		for (String model : new String[] { "sci_Montage_100" }) {
			HashMap<String, Object> paras = new HashMap<String, Object>();
			paras.put("algorithm", "NSGAII"); // TODO change here
			paras.put("dataset", model);
			paras.put("seed", System.currentTimeMillis());
			paras.put("popSize", 50);
			paras.put("maxEval", 250);
			paras.put("arxvSize", 10); // spea2 used only
			paras.put("cxProb", 1.0);
			paras.put("cxRandChangeProb", 0.6);
			paras.put("mutProb", 0.6);
			paras.put("bitMutProb", 1.0);
			long start_time = System.currentTimeMillis();
			EMSC runner = new EMSC();
			runner.execute(paras);
			System.out.println("EXEC TIME = " + (System.currentTimeMillis() - start_time) / 1000);
		}
	}
}
